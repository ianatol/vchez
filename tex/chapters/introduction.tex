\chapter{Introduction}
As computers become ubiquitous in our lives, the software running on them becomes both more important and more complex. We are lucky to live at a time where computers can help us to live longer by powering advanced medical equipment, but the grave consequences of programming errors in the software of these computers is self-evident. This convergence of increasing complexity and importance is troubling, since these two concepts are traditionally at odds. 

To confront these issues, many researchers are hard at work with the goal of ensuring reliability of software. One approach to this problem, \textit{static analysis}, aims to prove properties of programs before they are run. Generally, tools that utilize static analysis aim to make claims about the behavior of programs. More specifically, by defining a programs behavior as the meaning of its source code in the \textit{semantics} of its language, we can devise formal proofs about how a program will function.

However, the process of executing a programs source code is not trivial. For many languages, code written by humans must be translated by a tool called a \textit{compiler} to something that the computer can actually execute. If the compiler makes an error in translation, any proof about the behavior of that program is now forfeit. Essentially, any proof made about the source code of a program makes the assumption that a compiler will faithfully translate its meaning to the computer.

As our programs grow in size and complexity, so too must the languages we write them in and their corresponding compilers. This means that our compilers themselves are caught in the same troubling convergence of increasing complexity and importance. One natural thought is to look to prove properties about the compilers themselves. Namely, we want to prove that our compilers translate correctly --- that the meaning of any program given to them is preserved in the process of translation. If we can do that, then we know that proofs about the \textit{source language}, or the language that the compiler is performing its translation on, are preserved through the compilation process.

In this paper, we provide a proof of correctness for a single pass of the Chez Scheme compiler, called \textit{np-}\caname. To support and validate our reasoning, we provide two different frameworks for producing evidence of our proof. The first is a formal model of the subset of the Scheme semantics that we use to reason about the compiler pass. Built using the Coq proof assistant, this model provides a framework for using intuitionistic logic to prove properties about Scheme and Scheme programs with a high degree of trustworthiness. This model was meant to be the basis of a mechanization of our proof, but the full mechanization ended up being outside of the scope of this thesis. The second framework provides a way of testing individual programs for semantic preservation over the \caname\ transformation. This framework, created with the Racket language, uses an existing implementation of the Scheme formal semantics to validate our proof technique on given example programs.

We hope that this work can serve as a trustworthy proof of the correctness of this compiler pass, and more generally hope to see a future where we can wholly trust that our compilers are translating critically important programs correctly.